<svg id="svginline">
    <g id="viewport">
        <g id="anterior_torso_general">
            <path fill="#F1F1F2" d="M174,276Q295.6,381.8,286,393C271.6,409.8,115.2,398.5,78,388S42.8,347.15,38,323S41.95,259.25,46,227S32.599999999999994,132.75,65,108S245.65,36.8,262,62Q272.9,78.8,174,276" />
            <!--       <path fill="#F1F1F2" d="M32.5,202.1C32.5,202.1,32.5,202.2,32.5,202.1c0,0,0.2,3.8,0.3,5.1c0.1,1.2,0.1,5.7,1.1,5.8
                              c1,0.1,2.2,0,2.2-5.3c0-4.7-0.1-6.1-0.1-6.4C34.9,201.6,33.8,201.9,32.5,202.1z"/> -->
        </g>
    </g>
    <foreignObject x="0" y="0" width="100%" height="100%">

        <body xmlns="http://www.w3.org/1999/xhtml">
            <div id="draggable" class="target"></div>
        </body>
    </foreignObject>
</svg>
<script src="https://d3js.org/d3.v3.min.js"></script>

<script>

    var line = d3.svg.line()
        .interpolate("cardinal");

    var svg = d3.select("svg")
        .attr("width", width)
        .attr("height", height);

    // var path = svg.append("path")
    // .datum([[174,276],[286,393],[78,388],[38,323],[46,227],[65,108],[262,62],[174,276]])
    // .attr("d", line);

    var path = svg.select("#anterior_torso_general path");
    // path.datum([[174,276],[286,393],[78,388],[38,323],[46,227],[65,108],[262,62],[174,276]]);

    console.log(svg);
    // var path = svg
    //   .append("circle")
    //   .attr("class", "circle intersects")
    //   .datum([200, 200, 120])
    //   .call(positionCircle)
    //   .attr("r", function(d) {
    //     return d[2];
    //   });


    var line = svg.append("line");

    var circle = svg.append("circle")
        .attr("cx", -10)
        .attr("cy", -10)
        .attr("r", 3.5);

    // svg.append("rect")
    //     .attr("width", width)
    //     .attr("height", height)
    //     .on("mousemove", mousemoved);

    function mousemoved() {
        var m = d3.mouse(this);
        var p = closestPoint(path.node(), m);
        line.attr("x1", p[0]).attr("y1", p[1]).attr("x2", m[0]).attr("y2", m[1]);
        circle.attr("cx", p[0]).attr("cy", p[1]);
    }

    function closestPoint(pathNode, point) {
        var pathLength = pathNode.getTotalLength();
        // var pathLength = 2.0 * Math.PI * 100;
        var precision = 8;
        var best;
        var bestLength;
        var bestDistance = Infinity;


        // linear scan for coarse approximation
        for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
            if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
                best = scan, bestLength = scanLength, bestDistance = scanDistance;
            }
        }

        // binary search for precise estimate
        precision /= 2;
        while (precision > 0.5) {
            var before,
                after,
                beforeLength,
                afterLength,
                beforeDistance,
                afterDistance;
            if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(
                    beforeLength))) < bestDistance) {
                best = before, bestLength = beforeLength, bestDistance = beforeDistance;
            } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after =
                    pathNode.getPointAtLength(afterLength))) < bestDistance) {
                best = after, bestLength = afterLength, bestDistance = afterDistance;
            } else {
                precision /= 2;
            }
        }

        best = [best.x, best.y];
        best.distance = Math.sqrt(bestDistance);
        return best;

        function distance2(p) {
            var dx = p.x - point[0],
                dy = p.y - point[1];
            return dx * dx + dy * dy;
        }
    }

    var targetOutOfBounds = false;
    var $positionTarget = $("#draggable");

    $positionTarget.draggable({
        // containment: "parent",
        start: function () {},
        drag: function () {
            var targetCenter = getTargetCenter();

            if (isTargetOutOfBounds()) {
                targetOutOfBounds = true;
                $positionTarget.css({
                    "background-color": "red"
                });
            } else {
                targetOutOfBounds = false;

                $positionTarget.css({
                    "background-color": "transparent"
                });
            }
        },
        stop: function () {
            if (targetOutOfBounds) {
                var targetCenter = getTargetCenter();
                console.log(path.node());
                var p = closestPoint(path.node(), [targetCenter.x, targetCenter.y]);
                var dx = p[0] - targetCenter.x;
                var dy = p[1] - targetCenter.y;
                // var d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
                // var padding = 0;
                // var ratio = (d + padding) / d;

                targetCenter.x += dx; // * ratio;
                targetCenter.y += dy; // * ratio;



                $positionTarget.animate({
                        left: targetCenter.x - $positionTarget.width() / 2 + "px",
                        top: targetCenter.y - $positionTarget.height() / 2 + "px"
                    },
                    "slow",
                    "easeOutBounce"
                );
                $positionTarget.css({
                    "background-color": "transparent"
                });

                targetOutOfBounds = false;
            }
        }
    });

    var targetPosition;
    var displayTarget = true;

    function positionTarget() {
        targetCenter = {
            x: $(window).width() / 2,
            y: $(window).height() / 2
            // x: containerBounds.left + $targetContainer.width() / 2,
            // y: containerBounds.top + $targetContainer.height() / 2
        };

        console.log("$(window): " + $(window).width() + " X " + $(window).height());
        console.log("targetCenter: " + targetCenter.x + " X " + targetCenter.y);
        $positionTarget.css({
            left: targetCenter.x - $positionTarget.width() / 2 + "px",
            top: targetCenter.y - $positionTarget.height() / 2 + "px"
        });
    }

    $(window).resize(function () {
        positionTarget();
    });

    positionTarget();

    function getTargetCenter() {
        var position = $positionTarget.position();
        return {
            x: position.left + $positionTarget.width() / 2,
            y: position.top + $positionTarget.height() / 2
        };
    }

    function isTargetOutOfBounds() {
        // var targetCenter = getTargetCenter();
        //
        // return !intersects(path.datum(), [targetCenter.x, targetCenter.y]);

        return true;
    }
</script>